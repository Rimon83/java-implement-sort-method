Heap sort:

A heap sort is binary tree and the process of removing largest element at a time from the heap part of the list, 
subsequently inserting it into the sorted part.

steps:

1. Using the array given, we should construct a heap and convert it to a maximum heap.

     7  10  45  23  75	33  18	26  54
      
                     7
             
              10           45
    
          23      75    33    18 

      26      54


 2. select max heap in this tree.

                    75
             
              7           45
    
          54      10    33    18 

      26      23

    75  7  45  54  10  33  18  26  23

3. swap the max heap 75 with the last element of the array 23 and inserted into sorted array.

    23  7  45  54  10  33  18  26  75   ---------> insert max heap into sorted array: 75

4. repeat the three steps above on the remaining elements in array.

                     23                                                                           54                                           
             
               7           45                                                               23          45
    
          54      10    33    18          select max heap                             26        10   33      18

      26                                    --------->                            7 

      54  23  45  26  10  33  18  7  
swap  7   23  45  26  10  33  18  54    -------->    insert max heap into sorted array: 54  75   


                      7                                                                  45
             
              23           45            select max heap                           26          33
    
          26      10    33    18          ------------>                        23      10    7     18

       45   26   33   23   10   7   18
swap   18   26   33   23   10   7   45    --------->  insert max heap into sorted array: 45  54  75



                      18                                                      33

                26          33         select max heap                  26           18      

           23       10    7             ----------->                23      10    7

      33   26   18   23   10   7
swap  7    26   18   23   10   33       ----------->  insert max heap into sorted array: 33  45  54  75


                   7                                                         26
  
             26       18               select max heap                  23        18

        23      10                    -------------->                7      10

      26   23   18   7   10 
swap  10   23   18   7   26           ---------------> insert max heap into sorted array: 26  33  45  54  75


                  10                                                      23

             23        18          select max heap                    10      18

          7                        --------------->                 7

      23   10   18   7
swap  7    10   18   23           ---------------> insert max heap into sorted array: 23  26  33  45  54  75

7   10    18    23   26   33   45   54   75



algorithm:

Firstly, it creates a heap (alike to a complete binary tree) from an array. The element at index 0 is palced at the root of the binary tree. 
Secondly, the heap is transformed into a max heap in which a parent node is greater or equal to its child nodes. If not, the parent node and the child node swap. 
In the next step, the first and the last node swap, and the last node is removed from heap. 
Heap sort repeats the steps listed above until the arrray is sorted. 

public static void heapSort(int[]array){
	for(int i = (array.length -1) /2; i >= 0; i--){
	adjustHeap(array, i, array.length);
}
	for(int i = array.length -1; i > 0; i--){
	int temp = array[i];
	array[i] = array[0];
	array[0] = temp;

	adjustHeap(array, 0, i);
}
}

    private static void adjustHeap(int[] array, int parent, int length) {
        int temp = array[parent];
        int lChild = 2 * parent + 1;

        while (lChild < length) {
            int rChild = lChild + 1;
            if (rChild < length && array[lChild] < array[rChild]) {
                lChild++;
            }

            if (temp >= arr[lChild]) {
                break;
            }

            arr[parent] = arr[lChild];

            parent = lChild;
            lChild = 2 * lChild + 1;
        }
        array[parent] = temp;
    }
}


  Time complexity: 
      best case = average case = worst case = O(nlogn)
  space complexity: 1
      

